{"version":3,"file":"DllBundlesControl.js","sourceRoot":"","sources":["../../src/DllBundlesControl.ts"],"names":[],"mappings":"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","sourcesContent":["const findRoot = require('find-root');\nconst jsonfile = require('jsonfile');\nimport * as Path from 'path';\nimport * as fs from 'fs';\n\nimport { DllBundleConfig, DllPackageConfig, DllBundlesPluginOptions } from './interfaces';\n\ninterface BundleState {\n  [key: string]: { bundle: string; version: string; };\n}\n\ninterface AnalyzedState {\n  current: PackageInfo[];\n  changed: PackageInfo[];\n  added: PackageInfo[];\n  removed: PackageInfo[];\n  error: PackageInfo[];\n}\n\nclass PackageInfo implements DllPackageConfig {\n  name: string;\n  path: string;\n  version: string;\n\n  error: Error;\n\n  constructor(public bundle: string, pkg: string | DllPackageConfig) {\n    if (typeof pkg === 'string') {\n      this.name = this.path = pkg;\n    } else {\n      this.name = pkg.name;\n      this.path = pkg.path;\n    }\n  }\n}\n\nconst BUNDLE_STATE_FILENAME: string = 'dll-bundles-state.json';\n\nexport class DllBundlesControl {\n\n\n  constructor(private bundles: DllBundleConfig[], private options: DllBundlesPluginOptions) { }\n\n  /**\n   * Check for bundles that requires a rebuild, based on the bundle configuration.\n   * Returns the bundles that requires rebuild.\n   * @returns {Promise<DllBundleConfig[]>}\n   */\n  checkBundles(): Promise<DllBundleConfig[]> {\n    return this.analyzeState()\n      .then( analyzed => {\n\n        // make a list of all bundles that are invalid, this is not related to the analyzed data\n        const bundleNames: string[] = this.bundles\n          .map( b => b.name )\n          .filter( name => this.bundleLooksValid(name) );\n\n        if (analyzed.error.length > 0) {\n\n          analyzed.error.forEach( p => {\n            console.error(p.error);\n          });\n\n          if (!this.options.ignorePackageError) {\n            throw new Error('DllBundlesPlugin: Some packages have errors.');\n          }\n        }\n\n        // get all bundles that requires changed based on analyzed data\n        // this is an aggregation for all bundles that need a rebuild.\n        analyzed.added.concat(analyzed.changed).concat(analyzed.removed).concat(analyzed.error)\n          .forEach( p => bundleNames.indexOf(p.bundle) === -1 && bundleNames.push(p.bundle) );\n\n        // return the DllHostBundleConfig of all bundles that need a rebuild.\n        return bundleNames\n          .map( bundleName => this.bundles.filter( bnd => bnd.name === bundleName)[0] )\n      });\n  }\n\n\n  /**\n   * Collect metadata from all packages in all bundles and save it to a file representing the current\n   * state. File is saved in the `dllDir`.\n   * @returns {Promise<void>}\n   */\n  saveBundleState(): Promise<void> {\n    return this.getMetadata()\n      .then( metadata => {\n\n        const bundleState: BundleState = metadata\n          .filter( m => !m.error)\n          .reduce( (state, pkg) => {\n            state[pkg.name] = { bundle: pkg.bundle, version: pkg.version };\n            return state;\n          }, {} as any);\n\n        fs.writeFileSync(Path.join(this.options.dllDir, BUNDLE_STATE_FILENAME), JSON.stringify(bundleState, null, 2));\n      });\n  }\n\n\n  /**\n   * Check if the bundle name is valid.\n   * This is a shallow check, it only checks for the existence of files that represent a DLL bundle.\n   * @param name\n   * @returns {boolean}\n   */\n  private bundleLooksValid(name: string): boolean {\n    return !fs.existsSync(Path.join(this.options.dllDir, `${name}.dll.js`))\n      || !fs.existsSync(Path.join(this.options.dllDir, `${name}-manifest.json`));\n  }\n\n  /**\n   * Collect metadata from all packages in all bundles\n   * @returns {Promise<PackageInfo[]>}\n   */\n  private getMetadata(): Promise<PackageInfo[]> {\n    const promises: Promise<PackageInfo>[] = this.bundles\n      .map( b => b.packages.map( p => new PackageInfo(b.name, p) ) )\n      .reduce( (prev, curr) => prev.concat(curr), [])\n      .map( pkgInfo => {\n        return this.getPackageJson(pkgInfo.path)\n          .then( pkgJson => {\n            pkgInfo.version = pkgJson.version;\n            if (pkgInfo.name !== pkgJson.name) {\n              throw new Error(`Package name mismatch, Expected ${pkgInfo.name} but found ${pkgJson.name} `);\n            }\n          })\n          .catch( err => pkgInfo.error = err )\n          .then( () => pkgInfo );\n      });\n\n    return Promise.all(promises);\n  };\n\n  /**\n   * Find the diff between the current bundle state to the last bundle state.\n   * The current bundle state is the required bundle state, the bundle information entered by the user.\n   * The last bundle state is a representation of the last build saved in JSON file combined with\n   * the state of physical packages on the file system.\n   * @returns {Promise<AnalyzedState>}\n   */\n  private analyzeState(): Promise<AnalyzedState> {\n    return this.getMetadata() // get metadata for the required bundle configuration\n      .then( packages => {\n        const result = {\n          current: [],\n          changed: [],\n          added: [],\n          removed: [],\n          error: []\n        };\n\n        const bundleState = this.getBundleSate();\n        const pkgCache = {\n          del: (pkgInfo: PackageInfo) =>  {\n            delete bundleState[pkgInfo.name];\n            pkgCache.hist.push(pkgInfo.name);\n          },\n          deleted: (pkgInfo: PackageInfo) =>  pkgCache.hist.indexOf(pkgInfo.name) > -1,\n          hist: []\n        };\n\n\n        // compare to the bundle state, i.e: the last state known\n        // we have 4 possible outcomes for each package: No change, version change, added, removed.\n        packages.forEach( pkgInfo => {\n          if (pkgInfo.error) {\n            result.error.push(pkgInfo);\n            pkgCache.del(pkgInfo);\n          } else if (bundleState.hasOwnProperty(pkgInfo.name)) { // if the old sate has this package:\n            if (bundleState[pkgInfo.name].version === pkgInfo.version) {\n              result.current.push(pkgInfo);\n            } else {\n              result.changed.push(pkgInfo);\n            }\n            // we delete it from the bundle list so at the end we have a bundle state that\n            // has packages that were removed\n            pkgCache.del(pkgInfo);\n          } else { // old package didn't have this package, its new (added)\n            if (!pkgCache.deleted(pkgInfo)) {\n              // first we check if it wasn't deleted in previous loop\n              // this is when 2 names for different paths are set\n              // it can happen if the main file is not importing all parts of the package.\n              result.added.push(pkgInfo);\n            }\n\n          }\n        });\n\n        /**\n         * All packages left in the bundle state are those removed from last bundle build.\n         */\n        result.removed = Object.keys(bundleState).map( k => new PackageInfo(bundleState[k].bundle, k) );\n\n        return result;\n      });\n  }\n\n  /**\n   * Load the last metadata state about all packages in all bundles\n   * @returns BundleState\n   */\n  private getBundleSate(): BundleState {\n    if (fs.existsSync(Path.join(this.options.dllDir, BUNDLE_STATE_FILENAME))) {\n      return <any>jsonfile.readFileSync(Path.join(this.options.dllDir, BUNDLE_STATE_FILENAME));\n    } else {\n      return {} as any;\n    }\n  }\n\n  /**\n   * Returns package json based on a URI.\n   *\n   * Currently supports only node resolved value.\n   *\n   * Returns a Promise for future integration with webpack resolve system.\n   *\n   * @param uri\n   * @returns Promise<{name: string, version: string}>\n   */\n  private getPackageJson(uri: string): Promise<undefined | {name: string, version: string}> {\n    try {\n      const pkg = require(this.getPackageJsonPath(uri));\n\n      if(!pkg.name || !pkg.version) {\n        throw new Error('Invalid package.json');\n      }\n\n      return Promise.resolve(pkg);\n    } catch (err) {\n      return Promise.reject(err);\n    }\n  }\n\n  private getPackageJsonPath(uri: string): string {\n    const location = findRoot(require.resolve(uri));\n    return Path.join(location, 'package.json');\n\n    // if (fs.statSync(location).isDirectory()) {\n    //   return Path.join(location, 'package.json');\n    // } else {\n    //   return Path.join(Path.dirname(location), 'package.json');\n    // }\n  }\n}\n"]}